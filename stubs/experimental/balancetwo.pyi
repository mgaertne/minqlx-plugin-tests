import threading
from abc import abstractmethod, ABCMeta
from datetime import datetime
from requests import Session
from typing import Callable, Iterator, Sequence, TypeVar, Iterable, Generic, Mapping

from minqlx import AbstractChannel, Player, Plugin
from minqlx.database import Redis

SteamId = int
PLAYER_BASE: str
IPS_BASE: str
SUPPORTED_GAMETYPES: Iterable[str]

def requests_retry_session(
    retries: int = ...,
    backoff_factor: float = ...,
    status_forcelist: tuple[int, int, int] = ...,
    session: Session | None = ...,
) -> Session: ...
def identify_reply_channel(channel: AbstractChannel) -> AbstractChannel: ...
def remove_trailing_color_code(text: str) -> str: ...
def other_team(team: str) -> str: ...
def format_team(team: str) -> str: ...
def report_ratings_for_team(
    channel: AbstractChannel,
    team: list[Player],
    gametype: str,
    primary_rating_provider: RatingProvider,
    secondary_rating_provider: RatingProvider,
    *,
    _primary_rating_prefix: str = ...,
    _secondary_rating_prefix: str = ...
) -> None: ...

# noinspection PyPep8Naming
class balancetwo(Plugin):
    database: Redis
    rating_system: str
    ratingLimit_kick: bool
    ratingLimit_min: dict[str, int | float]
    ratingLimit_max: dict[str, int | float]
    ratingLimit_minGames: dict[str, int]
    minimum_suggestion_diff: dict[str, int | float]
    minimum_suggestion_stddev_diff: dict[str, float]
    last_action: str
    auto_switch: bool
    repeat_vetoed_switches: bool
    unique_player_switches: bool
    auto_rebalance: bool
    reply_channel: str
    show_steam_ids: bool
    allowed_privacy: list[str]
    max_num_join_attempts: int
    connectthreads: dict[str, ConnectThread]
    kickthreads: dict[SteamId, KickThread]
    exceptions: set[SteamId]
    jointimes: dict[SteamId, datetime]
    last_new_player_id: SteamId | None
    previous_teams: tuple[list[SteamId], list[SteamId]]
    previous_map: str | None
    previous_gametype: str | None
    previous_ratings: dict[str, RatingProvider]
    ratings: dict[str, RatingProvider]
    rating_diffs: dict[str, dict[SteamId, dict[str, float]]]
    informed_players: list[SteamId]
    vetoed_switches: list[Suggestion]
    switched_players: list[SteamId]
    switch_suggestion: Suggestion | None
    in_countdown: bool
    twovstwo_steam_ids: list[SteamId]
    twovstwo_combinations: list[tuple[SteamId, SteamId]]
    twovstwo_iter: Iterator[tuple[SteamId, SteamId]]
    privacy_checks_enabled: bool
    join_attempts: dict[SteamId, int]
    def __init__(self) -> None: ...
    def parse_rating_limit(self, cvar: str) -> dict[str, int | float]: ...
    def parse_suggestion_minimum(self, cvar: str) -> dict[str, int | float]: ...
    def fetch_elos_from_all_players(self) -> None: ...
    async def fetch_ratings(
        self, steam_ids: list[SteamId], mapname: str | None = ...
    ) -> None: ...
    def fetch_mapbased_ratings(
        self, steam_ids: list[SteamId], mapname: str | None = ...
    ): ...
    def append_ratings(self, rating_provider_name: str, json_result: dict) -> None: ...
    def cmd_elocheck(
        self, player: Player, msg: str, channel: AbstractChannel
    ) -> int | None: ...
    def do_elocheck(
        self, player: Player, target: str, channel: AbstractChannel
    ) -> None: ...
    def find_target_player(self, target: str) -> list[Player]: ...
    def reply_func(
        self, player: Player, channel: AbstractChannel
    ) -> Callable[[str], None]: ...
    def used_steam_ids_for(self, steam_id: SteamId) -> list[int]: ...
    def fetch_aliases(self, steam_ids: list[SteamId]) -> dict[SteamId, list[str]]: ...
    def format_player_elos(
        self,
        a_elo: RatingProvider,
        b_elo: RatingProvider,
        truskill: RatingProvider,
        map_based_truskill: RatingProvider | None,
        steam_id: SteamId,
        indent: int = ...,
        aliases: list[str] | None = ...,
    ) -> str: ...
    def format_player_name(self, steam_id: SteamId) -> str: ...
    def resolve_player_name(self, steam_id: SteamId) -> str: ...
    def cmd_aliases(
        self, player: Player, msg: str, channel: AbstractChannel
    ) -> int | None: ...
    def do_aliases(
        self, player: Player, target: str, channel: AbstractChannel
    ) -> None: ...
    def format_player_aliases(self, steam_id: SteamId, aliases: list[str]) -> str: ...
    def cmd_ratings(
        self, _player: Player, _msg: str, channel: AbstractChannel
    ) -> None: ...
    def cmd_switch_elo_changes_notifications(
        self, player: Player, _msg: str, _channel: AbstractChannel
    ) -> int | None: ...
    def wants_to_be_informed(self, steam_id: SteamId) -> bool: ...
    def cmd_balance(
        self, player: Player, _msg: str, _channel: AbstractChannel
    ) -> int | None: ...
    def callback_balance(self, channel: AbstractChannel) -> None: ...
    def dominant_team_for_steam_ids(self, steam_ids: list[SteamId]) -> str: ...
    def find_time(self, steam_id: SteamId) -> datetime: ...
    def find_balanced_teams(
        self, steam_ids: list[SteamId]
    ) -> tuple[list[SteamId], list[SteamId]]: ...
    def find_non_recent_small_balanced_teams(
        self, steam_ids: list[SteamId]
    ) -> tuple[list[SteamId], list[SteamId]]: ...
    def find_large_balanced_teams(
        self, steam_ids: list[SteamId]
    ) -> tuple[list[SteamId], list[SteamId]]: ...
    def report_teams(
        self,
        red_team: list[SteamId],
        blue_team: list[SteamId],
        channel: AbstractChannel,
    ) -> None: ...
    def configured_rating_provider_name(self) -> str: ...
    def team_average(
        self,
        gametype: str,
        steam_ids: list[SteamId],
        rating_provider: RatingProvider | None = ...,
    ) -> float: ...
    def team_stddev(
        self,
        steam_ids: list[SteamId],
        gametype: str,
        *,
        mu: float | None = ...,
        rating_provider: RatingProvider | None = ...
    ) -> float: ...
    def cmd_last_action(
        self, _player: Player, msg: str, channel: AbstractChannel
    ) -> int | None: ...
    def cmd_teams(
        self, player: Player, _msg: str, channel: AbstractChannel
    ) -> int | None: ...
    def collect_suggestions(
        self, teams: Mapping[str, list[Player]], gametype: str, channel: AbstractChannel
    ) -> None: ...
    def filtered_suggestions(
        self, teams: Mapping[str, list[Player]], gametype: str
    ) -> list[Suggestion]: ...
    def satisfies_minimum_suggestion_parameters(
        self, suggestion: Suggestion, stddev_diff: float
    ) -> bool: ...
    def minimum_suggestion_parameters(self) -> tuple[int | float, int | float]: ...
    def possible_switches(
        self, teams: Mapping[str, list[Player]], gametype: str
    ) -> list[Suggestion]: ...
    def handle_suggestions_collected(
        self, possible_switches: list[Suggestion], channel: AbstractChannel
    ) -> None: ...
    def rating_strategy(self, _strategy: str) -> SuggestionRatingStrategy: ...
    def cmd_do(self, _player: Player, _msg: str, _channel: AbstractChannel) -> None: ...
    def cmd_dont(
        self, _player: Player, _msg: str, _channel: AbstractChannel
    ) -> None: ...
    def cmd_agree(
        self, player: Player, _msg: str, _channel: AbstractChannel
    ) -> None: ...
    def execute_suggestion(self) -> None: ...
    def cmd_veto(
        self, player: Player, _msg: str, _channel: AbstractChannel
    ) -> None: ...
    def cmd_nokick(
        self, player: Player, msg: str, channel: AbstractChannel
    ) -> int | None: ...
    def cmd_switch_privacy_checks(
        self, _player: Player, msg: str, channel: AbstractChannel
    ) -> int | None: ...
    def disable_policy_check(self, channel: AbstractChannel) -> None: ...
    def enable_policy_check(self, channel: AbstractChannel) -> None: ...
    def cmd_add_exception(
        self, player: Player, msg: str, _channel: AbstractChannel
    ) -> int | None: ...
    def cmd_del_exception(
        self, player: Player, msg: str, _channel: AbstractChannel
    ) -> int | None: ...
    def handle_map_change(self, mapname: str, _factory: str) -> None: ...
    def clean_up_kickthreads(self) -> None: ...
    def fetch_and_diff_ratings(self, mapname: str) -> None: ...
    def handle_player_connect(self, player: Player) -> str | None: ...
    def check_player_ratings(self, steam_id: SteamId) -> str | None: ...
    def rating_provider_for(
        self, rating_provider_name: str
    ) -> SkillRatingProvider | None: ...
    def check_player_privacy(self, steam_id: SteamId) -> str | None: ...
    def remove_thread(self, threadname: str) -> None: ...
    def record_join_times(self, steam_id: SteamId) -> None: ...
    def schedule_kick_for_players_outside_rating_limits(
        self, steam_ids: list[SteamId]
    ) -> None: ...
    def has_exception_to_play(self, steam_id: SteamId) -> bool: ...
    def handle_player_disconnect(self, player: Player, _reason: str) -> None: ...
    def handle_team_switch_attempt(
        self, player: Player, old: str, new: str
    ) -> int | None: ...
    def check_privacy_settings(self, player: Player) -> int | None: ...
    def is_player_with_allowed_privacy_settings(
        self, steam_id: SteamId, rating_provider: RatingProvider | None = ...
    ) -> bool: ...
    def colored_qlstats_instructions(self) -> str: ...
    def check_rating_limit(self, player: Player) -> int | None: ...
    def is_player_within_configured_rating_limit(self, steam_id: SteamId) -> bool: ...
    def is_player_above_lower_rating_limit(self, steam_id: SteamId) -> bool: ...
    def try_auto_rebalance(self, player: Player, old: str, new: str) -> int | None: ...
    def calculate_player_average_difference(
        self, gametype: str, team1: list[Player], team2: list[Player]
    ) -> float: ...
    def handle_team_switch(
        self, player: Player, _old_team: str, new_team: str
    ) -> None: ...
    def inform_about_rating_changes(self, player: Player) -> None: ...
    def format_rating_diffs_for_rating_provider_name_and_player(
        self, rating_provider_name: str, steam_id: SteamId
    ) -> str | None: ...
    def handle_game_countdown(self) -> None: ...
    def handle_round_countdown(self, _round_number: int) -> None: ...
    def announce_evening_up_teams(self) -> None: ...
    def identify_player_to_move(self) -> Player | None: ...
    def handle_round_start(self, _round_number: int) -> None: ...
    def balance_before_round_start(self) -> None: ...
    def find_player_movements_to_even_teams(self): ...
    def handle_game_end(self, data: dict) -> None: ...
    def record_team_stats(self, gametype: str) -> None: ...
    def team_stats(
        self, team: list[Player], gametype: str
    ) -> dict[SteamId, list[int | float]]: ...

FILTERED_OUT_GAMETYPE_RESPONSES: Iterable[str]

class SkillRatingProvider:
    name: str
    url_base: str
    balance_api: str
    timeout: int
    def __init__(
        self, name: str, url_base: str, balance_api: str, timeout: int = ...
    ) -> None: ...
    async def fetch_elos(
        self, steam_ids: list[SteamId], *, headers: dict[str, str] | None = ...
    ) -> dict | None: ...

TRUSKILLS: SkillRatingProvider
A_ELO: SkillRatingProvider
B_ELO: SkillRatingProvider

class RatingProvider:
    jsons: list[dict]
    def __init__(self, json: dict) -> None: ...
    def __iter__(self) -> Iterator[SteamId]: ...
    def __contains__(self, item: object) -> bool: ...
    def __getitem__(self, item: object) -> object | dict | PlayerRating: ...
    def __sub__(self, other: object) -> dict[SteamId, dict[str, float]]: ...
    @staticmethod
    def from_json(json_response: dict) -> RatingProvider: ...
    def append_ratings(self, json_response: dict) -> None: ...
    def player_data_for(self, steam_id: SteamId) -> dict | None: ...
    def gametype_data_for(self, steam_id: SteamId, gametype: str) -> dict: ...
    def rating_for(self, steam_id: SteamId, gametype: str) -> int | float | None: ...
    def games_for(self, steam_id: SteamId, gametype: str) -> int: ...
    def rated_gametypes_for(self, steam_id: SteamId) -> list[str]: ...
    def privacy_for(self, steam_id: SteamId) -> str | None: ...
    def rated_steam_ids(self) -> list[SteamId]: ...
    def format_elos(self, steam_id: SteamId) -> str: ...

class PlayerRating:
    ratings: dict
    time: int
    local: bool
    def __init__(self, ratings, _time: int = ..., local: bool = ...) -> None: ...
    def __iter__(self) -> Iterator[int | float]: ...
    def __contains__(self, item: object) -> bool: ...
    def __getitem__(self, item: object) -> dict[str, int | float | str | bool]: ...
    def __getattr__(self, attr: str) -> str: ...

class ConnectThread(threading.Thread):
    rating_provider: SkillRatingProvider
    _steam_id: SteamId
    fetched_result: dict | None
    def __init__(
        self, steam_id: SteamId, rating_provider: SkillRatingProvider
    ) -> None: ...
    def run(self) -> None: ...

class SuggestionRatingStrategy(metaclass=ABCMeta):
    @abstractmethod
    def best_suggestion(self, suggestions: list[Suggestion]) -> Suggestion: ...

class DiffSuggestionRatingStrategy(SuggestionRatingStrategy):
    def best_suggestion(self, suggestions: list[Suggestion]) -> Suggestion: ...

class SuggestionQueue:
    suggestions: list[Suggestion] | None
    strategy: SuggestionRatingStrategy
    def __init__(
        self,
        items: list[Suggestion] | None = ...,
        strategy: SuggestionRatingStrategy = ...,
    ) -> None: ...
    def __len__(self) -> int: ...
    def best_suggestion(self) -> Suggestion | None: ...

class Suggestion:
    red_player: Player
    blue_player: Player
    avg_diff: float
    stddev_diff: float
    _agreed: list[SteamId]
    auto_switch: bool
    def __init__(
        self,
        red_player: Player,
        blue_player: Player,
        avg_diff: float,
        stddev_diff: float = ...,
    ) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def announcement(self) -> str: ...
    def agree(self, player: Player) -> None: ...
    def agreed(self, player: Player) -> bool: ...
    def all_agreed(self) -> bool: ...
    def affected_steam_ids(self) -> list[SteamId]: ...
    def execute(self) -> None: ...
    @property
    def max_score(self) -> int: ...
    @property
    def score_sum(self) -> int: ...

class KickThread(threading.Thread):
    steam_id: SteamId
    kickmsg: str
    go: bool
    def __init__(self, steam_id: SteamId, kickmsg: str) -> None: ...
    def try_msg(self) -> None: ...
    def try_mute(self) -> None: ...
    def try_kick(self) -> None: ...
    def run(self) -> None: ...
    def stop(self) -> None: ...

class PlayerMovedToSpecError(Exception):
    player: Player
    def __init__(self, player: Player) -> None: ...

T = TypeVar("T")

class RandomIterator(Generic[T]):
    seq: Sequence[T]
    random_seq: Sequence[T]
    iterator: Iterator[T]
    def __init__(self, seq: Sequence[T]) -> None: ...
    def __iter__(self) -> Iterator[T]: ...
    def __next__(self) -> T: ...
