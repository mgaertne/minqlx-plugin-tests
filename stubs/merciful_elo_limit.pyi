from typing import TYPE_CHECKING
from threading import Thread

from minqlx import Plugin

if TYPE_CHECKING:
    from typing import Iterable
    from threading import Event
    from requests import Session

    from minqlx import AbstractChannel, Player

SteamId = int

APPLICATION_GAMES_KEY: str
ABOVE_GAMES_KEY: str

SUPPORTED_GAMETYPES: Iterable[str]

def requests_retry_session(
    retries: int = ...,
    backoff_factor: float = ...,
    status_forcelist: tuple[int, int, int] = ...,
    session: Session | None = ...,
) -> Session: ...
def identify_reply_channel(channel: AbstractChannel) -> AbstractChannel: ...
def is_player_in_exception_list(player: Player) -> bool: ...

# noinspection PyPep8Naming
class merciful_elo_limit(Plugin):
    min_elo: int
    application_games: int
    above_games: int
    banned_days: int
    connectthreads: dict[SteamId, ConnectThread]

    tracked_player_sids: set[SteamId]
    announced_player_elos: set[SteamId]

    def __init__(self) -> None: ...
    def handle_map_change(self, _mapname: str, _factory: str) -> None: ...
    def handle_player_connect(self, player: Player) -> int | str: ...
    def player_has_been_tracked(self, steam_id: SteamId) -> bool: ...
    def gaming_period_start(self) -> float: ...
    def player_has_application_games_left(self, steam_id: SteamId) -> bool: ...
    def application_games_of_player(self, steam_id: SteamId) -> list[float]: ...
    def next_game_available_at(self, steam_id: SteamId) -> str: ...
    def fetch_elos_of_players(self, players: list[Player]) -> None: ...
    def handle_player_loaded(self, player: Player) -> None: ...
    def handle_round_countdown(self, _round_number: int) -> None: ...
    def callback_ratings(
        self, _players: list[Player], _channel: AbstractChannel
    ) -> None: ...
    def handle_player_after_fetching_ratings(self, player: Player) -> None: ...
    def is_player_in_exception_list(self, player: Player) -> bool: ...
    def get_value_from_db_or_zero(self, key: str) -> int: ...
    def elo_for_player(self, player: Player) -> int | None: ...
    def warn_lowelo_player(self, player: Player) -> None: ...
    def blink2(
        self, player: Player, message: str, count: int = ..., interval: float = ...
    ) -> None: ...
    def handle_round_start(self, _round_number: int) -> None: ...
    def handle_player_at_round_start(self, player: Player) -> None: ...
    def cmd_mercis(
        self, _player: Player, _msg: list[str], channel: AbstractChannel
    ) -> None: ...
    def cmd_merci(
        self, player: Player, msg: list[str], channel: AbstractChannel
    ) -> int: ...
    def remaining_application_games_for_player(self, steam_id: SteamId) -> int: ...
    def remove_thread(self, sid: SteamId) -> None: ...
    def find_player_sid(self, player: Player, target: str) -> int | None: ...

class ConnectThread(Thread):
    _balance_api: str
    _steam_id: SteamId
    _elo: dict[str, dict[str, int]] | None
    _is_parsed: Event

    def __init__(self, steam_id: SteamId, balance_api: str) -> None: ...
    def is_parsed(self) -> bool: ...
    def elo_for(self, gametype: str) -> int: ...
    def run(self) -> None: ...
